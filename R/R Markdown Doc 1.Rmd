---
title: "Exploring Dota2 Match Data"
author: "Louis MS"
date: "7 December 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

Dota 2 (Defence Of The Ancients) is a popular free-to-play multiplayer online battle arena (MOBA) that consists of two teams of five players against each other who fight for two sides; the Radiant and the Dire.  The objective of the game is for each team to gain access to the enemy base and destroy their large structure called an ‘Ancient’.  Each base is linked by three paths commonly referred to as ‘top, middle or lower lanes’.  Each lane has three towers and two barracks.  The towers act as defensive structures that automatically attack enemy units and the barracks act as spawn locations for AI-controlled units called ‘creeps’ that go out in waves along their corresponding lanes.  These will also automatically attack enemy units and structures they encounter.  The role for the human players is to escort their creep to the enemy base, helping to remove enemy towers, creep and players in their way while also defending their own towers from the same.  Figure 1 shows the minimap of a Dota 2 game showing the locations of all towers, barracks and Ancients in the game.

![Figure 1: Dota 2 mini map at start of the game where cubes (11/side) represent tower positions for Radiant (green) and Dire (red), smaller double-cubes (6/side)represent barracks location and non-cube (1/side) represents ‘Ancient’ location] (images/Dota_2_minimap.jpg)

Before the matches begin each player selects a hero from 112 different possibilities.  This large number to select from when first starting out in Dota 2 can be daunting.  It is advisable to get familiar with a range of different characters when first starting out but how do you choose which hero to try first?  To save time it is important to initially become familiar with the most successful hero but how can we determine this?  Once we have selected the hero we want, what is the best strategy?  Should we try to gather as much gold as we can?  Or should we gather xp / kills instead?  Or perhaps a balance between these variables are more likely to generate a better performance and win condition?

## The Dataset
A dataset containing a wide variety of information posted to Kaggle by user [Devin] (https://www.kaggle.com/devinanzelmo/dota-2-matches) has a very interesting range of variables set out in several CSV files.  This study will mainly focus on the analysis of two of these files:


match.csv 	- contains 50,000 observations over 10 variable
players.csv 	- contains 500,000 observations over 73 variables

```{r}
library(match.csv)
library(players.csv)

glimpse(match)
glimpse(players)
```

For this study the following variables will be used:

### Match.csv
Match_ID
Start_time (convert to date)
Duration (convert to minutes?)
Tower_status_Radiant
Tower_status_Dire
Radiant_Win


### Players.csv
Match_id
Account_id
Hero_id
Player_slot (to identify which side player is on: R or D)
Kills
Deaths
assists
Radiant Team Kills
Radiant Team Deaths
Dire Team Kills
Dire Team Deaths
Gold_per_min
Xp_per_min
All_gold_gains
All_gold_loss (death loss and purchases)
all_xp_gains

Some of these variables are raw data in the files, some will need to be generated from the raw data.

```{r}
MatchDF <- data_frame (match %>%
                        select(match_id, start_time, duration, tower_status_radiant, tower_status_dire, radiant_win)))

PlayersDF <- data_frame (players %>%
                           select(match_id, account_id, hero_id, player_slot, kills, deaths, assists, gold_per_min, xp_per_min))

```


For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
